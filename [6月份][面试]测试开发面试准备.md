# 光大科技终面准备

> 没问啥就根据你终面前填的一个表来问的 问问你兴趣爱好，个人性格，职业规划，最后再问问项目相关的....好像就这些了，其他的不记得了，时间太久了。

> 还说了会轮岗，在北边的上地、南礼士路、石景山三个地方轮，最后定岗基本就在石景山那里，我都懵了

>二面就非常简单了就随便聊了聊简历(学校，课程，还擅长哪些方面)。然后居然重点问了我的爱好😂一共可能就6.7分钟我觉得一半时间在聊兴趣爱好。

>我没记错的话一共是4个面试官，然后完全没问技术，就一直在聊天，感觉是在考察表达能力和沟通能力😂

> 全问我关于学校的事情

## 自我介绍

大家（面试官）好，我叫杨光，26岁，山东泰安人。

本科就读于211高校中国石油大学（华东），专业软件工程。本科主要是课程学习以及编程实践，在课程学习方面，学习成绩优异，连续三年获得优秀学生称号，以及学习优秀奖学金。大四时，本科综合成绩排名专业第八，保研至华东师范大学软件工程学院密码与网络安全系。在编程实践方面，在校期间完成多个Android APP，获得过齐鲁软件大赛三等奖以及校程序设计竞赛三等奖。毕业时完成毕业设计”黄岛房产信息抓取系统“。

研究生阶段就读于华东师范大学（985高校），主要研究方向无人机集群位置感知研究，参与的科研项目主要是研究完成无人机集群的多维探测和对抗技术研究。最终的工作成果最终搭建了一套无人机集群仿真平台，完成了无人机飞行碰撞理论工作。协助导师完成项目的中期考核以及最终验收工作。相关学术成果也整理成论文，发表在《IEEE Network》上。

根据自身的项目经历，熟悉前端以及后端开发，对其他的岗位也有所了解。希望能够加入到光大科技公司，为光大科技公司的发展做出自己的贡献。

## 兴趣爱好(貌似特别喜欢问兴趣爱好)

1. 喜欢研究历史。很多人喜欢旅游，他们可以在空间的维度上体验世界，我喜欢历史是因为可以在时间这个维度上体验世界。
   1. 喜欢什么朝代？没有特别喜欢某个朝代，在中华文明历史的长河中每个朝代都是独一无二的，都对中华文明的发展起到了推动作用。秦汉大一统时期，完成了中国从政治、军事、经济、文化上面的统一，奠定了中华文明制度基础。唐宋时期经济的高度发展，与世界各国之间的经济文化交流，向世界彰显了中华文明。明清时
   2. 那喜欢看什么书？喜欢看一些名人的传记。
2. 体育运动喜欢打羽毛球。读研期间会预定场地，与实验室的同学一起打球。

## 个人性格

优点

- 成熟稳重
- 责任心强
- 做事比较细心

在研究期间，导师以及实验室的同学都非常的信任我，我管理实验室的经费。实验室物品购买、同学们差旅费报销都是我负责的。两三年的时间都没有出现差错，无论是差旅费报销还是购买电脑等设备都是我负责的，而且没有出现差错。

- 待人和善

- 不喜欢去麻烦别人，能自己动手的事情绝对是自己去做。

**缺点**

- 与人沟通交流的能力需要得到提高。当时开始解除一个人的时候，往往能够成为朋友，但是我很少主动的去和陌生人交流。这个导致了我错过了一些机会、错过一些朋友。

## 职业规划

- 一年之内
  - 接受并且熟悉自己的岗位。学习岗位项目的知识，提高自己的能力。

- 三到五年
  - 这个时候应该去熟悉了项目的开发流程，在项目或者是工作小组中发挥重要的作用。

- 五到十年
  - 这个时候，技术成熟，项目经验丰富，有足够的的能力做到负责某个项目，或者领导某个小组。

我最自己的规划就是从一个普通成员到项目的骨干，再到一个项目负责者。这么一个规划路线。

## 项目相关

- 无人机项目
- 微信小程序
- 爬虫项目

## 户口问题

努力争取，毕竟我也是有长期在北京工作的打算。

但是也服从公司的安排。

## 入职问题

目前还在学校，在需要完成一些手续就可以拿到学位证。随时可以去公司入职。

六月份可能暂时还不行，但是七月份就没有问题了。

## 常规HR问题

## 自己需要问的问题

1. 如果自己的能力达到了公司的要求，希望后面的过程能够快速一点，因为自己下周一就要强制离校了。（不知道这个问题该不该说）

## 自己能不能胜任某项工作

例如前端，后端，测试，运维等等。

黄岛房产信息抓取系统就是一个全栈项目，包含了前端、后端、数据采集等等。同时自己也做过微信小程序、安卓APP。熟悉Java、Python、JS等多种语言。足够胜任前端、后端的工作。当然如果公司有其他的安排，我也能够接受，哪怕是真的不熟悉、不了解，也能够从头开始学起，我对自己的学习能力还是比较有信心的。

## 有多少offer，为什么没有offer？

目前还没有offer，因为自己去年九月份在准备公务员开始，今年三月份开始就在准备论文答辩的工作。一直到在完成毕业论文的答辩才开始找，这期间一些公司的岗位基本上饱和了，投了几个大厂的岗位，经过几轮面试最终还是没有能够满足对方的要求。

如果能够达到光大公司的要求，我肯定会选择加入光大公司。争取早一点入职。

## 为什么没有实习经历？

## 为什么会延期？

> 这两个在一起说吧。但是没有问到延期的时候不要主动的透露。

其实在入学的前半年，自己是有读博的想法，然后导师也比较看中我。安排我做当时实验室的大方向，无人机方向。一开始的时候情况还比较顺利，当时还是跟着几个学长做单无人机的工作，也帮助导师完成了了项目的中期考核、最终验收。

后面项目升级，变成无人机集群的安全研究。这个时候整个项目的难度就陡增，参与人员只剩下我和一个学弟，进展也非常的曲折，在于导师、还有国外的几个教授讨论的过程中也觉得自己不适合科研工作，外加上自己投稿的几篇论文也都没有中。于是放弃了科研的打算，当时决定去考公，但是考了几次觉得考上的几率太小了，可能要考上几年的时间，同时因为受疫情的影响，父母的生意就非常的艰难，我觉得自己应该是去撑起这个家了。

## 想做的岗位以及offer要求

例如前端，后端，测试，运维等等。

黄岛房产信息抓取系统就是一个全栈项目，包含了前端、后端、数据采集等等。同时自己也做过微信小程序、安卓APP。熟悉Java、Python、JS等多种语言。**足够胜任前端、后端的工作**。当然如果公司有其他的安排，我也能够接受，哪怕是真的不熟悉、不了解，也能够从头开始学起，我对自己的学习能力还是比较有信心的。

## 为什么想来光大/光大有什么吸引你的地方



## 问关于学校的事情

# 本日需要提高的东西

研究生期间的项目高大上化，简历上的项目也需要合理化。

在校的活动经历（好好说一下自己的为导师打工的经历）

OOP面向对象的思想好好解释

HTTP的方法，其中GET方法与POST方法要好好准备。

java语言基础。

进程与线程的区别

会的东西一定要说的非常的详细

cookies session有什么区别？？

多少种索引？如何建立索引

如何进行模糊搜索？

滑动窗口

## 自我介绍

大家（面试官）好，我叫杨光，26岁，山东泰安人。

本科就读于211高校中国石油大学（华东），专业软件工程，在校期间完成多个Android APP，获得过齐鲁软件大赛三等奖。学习成绩优异，连续三年获得优秀学生称号，以及学习优秀奖学金。毕业时完成毕业设计”黄岛房产信息抓取系统“。本科综合成绩排名专业第八，保研至华东师范大学软件学院密码与网络安全系。

研究生阶段就读于华东师范大学，主要研究方向无人机集群位置感知研究，该项目主要是研究无人机集群位置感知安全脆弱性，并进行试验验证。完成无人机集群的多维探测和对抗技术研究，最终搭建了一套无人机集群仿真平台，完成了无人机飞行碰撞理论工作。协助导师完成项目的中期考核以及最终验收工作。相关学术成果也整理成论文，发表在《IEEE Network》上。

主要使用的语言为Java，对其他的语言有所了解，未来工作的方向希望是Java后端开发工程师，希望能加入到贵公司。

## 无人机项目

通过卫星信号干扰实现对于无人机的飞行控制。

## 爬虫项目

**项目背景**：对青岛市黄岛区的房产信息数据进行采集、分析。

**项目功能**：（1）数据采集模块：利用Scrapy爬虫框架对黄岛区的房产信息进行抓取，存储到MySQL数据库，删除不符合要求、错误的信息；（2）数据展示模块：利用Django开发信息展示系统，在Web端对房产信息进行可视化展示，并且分析房产信息，得出房价走势，热点房源。

**主要职责**：整个项目的开发、迭代、系统部署、测试。项目使用Python语言开发，用Scrapy框架抓取数据并存储到MySQL数据库，利用Django框架开发Web应用程序，前端部分使用echarts.js对房产数据进行可视化展示。

在利用Scrapy爬虫框架爬取链家、安居客等网站上面的房产信息时遇到了网站的反爬虫机制，针对反爬虫机制进行分析，目前主流的反爬虫机制有

1. 根据Request Headers（请求头）中的“User-Agent”判断是否为爬虫。
2. 通过IP限制来反爬虫。如果一个固定的ip在短暂的时间内，快速大量的访问一个网站，该IP就会被封禁。
3. 需要登录才能访问。

我的解决方案有：

1. 请求头中添加user-agent，并且随机更换。
2. IP代理池。简单的说，就是通过ip代理，从不同的ip进行访问，这样就不会被封掉ip了。先抓取一些网站上分享的免费IP地址，再利用这些地址去爬取信息。
3. 注册账号，在浏览器登录，查看发送的cookie或token。爬虫在每次请求时也带上相应的cookie或token。

最终克服了该网站上面的反爬虫机制，成功爬取数据。

**延伸一下**，**豆瓣的反爬虫机制**：1、在没有携带 cookie 的情况下，如果某个 IP 短时间高并发请求网站，该 IP 会立马被封。当 IP 被封，登录豆瓣网站会解封。3、在携带 cookie 的情况下，某个 IP 请求网站过于频繁。豆瓣的反爬虫机制变为只封 cookie 不封 IP。也就说退出登录或者换个账号还能继续访问网站。

## 小程序项目

**项目背景**：基于微信小程序开发的家教小程序，该项目旨在为华师大校内学生提供合适的家教机会。

**项目功能**：（1）注册模块：注册并且上传基本信息、教学要求；（2）查询模块：根据基本信息以及教学要求查询合适的目标对象；（3）匹配模块：向目标对象发送申请，申请通过，完成学生与教师间的匹配；（4）个人中心模块：查看申请、发布、收藏等信息。                                           

**主要职责**：小程序教师端的开发、迭代、测试等工作。使用JavaScript完成业务逻辑开发，WXML构建页面结构，WXSS描述页面样式，Bomb云数据库存储数据。

项目介绍：在这个系统中学生/家长和教师可以分别进行注册，然后在平台进行个人信息的展示以及家教需求的匹配。此系统基于微信小程序平台进行开发，后台使用 Bmob 云数据库平台进行后端业务的支持，使用针对性改进优化的推荐算法进行内部推荐系统的构建，学生/家长和教师可以通过系统的智能匹配模块获取智能推荐的教师/学生对象。

项目主要功能：该家教系统包括登录系统模块、注册信息模块、教师信息展示模块、学生信息展示模块、投诉模块、智能匹配模块、个人中心模块、管理员审核模块等功能模块。

其中的智能匹配模块利用推荐算法给用户提供个性化的推荐列表，该推荐算法综合运用了基于物品的协同过滤算法、基于内容的推荐算法、基于标签的推荐算法,运用多种技术解决系统中可能存在的冷启动、稀疏性、扩展性等问题。

职责：主力开发人员。这个项目中我主要负责数据库表的设计，后端业务的实现。

## c++速成

数组：快速排序

字符串：字符串变形

指针：两个和为s的树。

链表：链表倒数第k个节点

其他再看看经典的几个题目。

栈

**小知识**：

除了字符串数组数组可以使用strlen()函数获取数组长度，其余的数组无法直接获取长度。

string可以实现string之间，string与字符c之间的相加减。

# 已投公司岗位

### 字节测开（失败）

6.10 周四面试

> 还可以
>
> 2021年6月15日至今没有任何的消息，估计是挂了。不知道什么时候能够被捞起来。
>
> 2021年6月15日17:44:49 收到感谢短信，凉了。意料之中。这差不多也意味着我进大公司的机会基本上是没有了。

hashcode值相同，那么equals一定相同吗？

### 百度测开（6.17一面）

可能要考算法

> 没有什么信心了，但是还是要准备的。趁着这个机会也开始提高自己。自己现在真的是不能够继续混下去了。

### 广州嘉为科技

未知

### 光大银行（马上一面）

6.8 笔试

6.11一面+二面，表现感觉良好

6.15早收到校园招聘登记表，这是不是意味着差不多了？

6.18终面，过程我觉得表现得非常的好，但是结果呢？不太看好。之前都是说常规HR问题，但是这个面试根本就不是。

1. 为什么延期？
2. 项目开发经验少，没有实习。
3. 笔试前面错了很多。Linux基本上完全不会。

祝自己好运吧。

> 不用慌，很简单，基本都能，表现自信点，突出你的学历，实践经历就可以了

>上来来段自我介绍
>
>问了问数据库优化的部分知识
>
>问了问实习时[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)碰到的问题
>
>问了问[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)解决需求的一整套流程
>
>问了问校内活动的事情

>一面: 
> [项目]()深挖(问的还挺细致的。这点要注意一下。我自己做的[项目]()因为时间原因。我自己都不太能答上来了π_π) 
>
> tcp和udp区别 
>
> tcp的应用协议 
>
> http和https的区别 
>
> ftp接口 
>
> linux下查看ip查看路由表 
>
> 给了一个具体的情况让你口述sql语句(增删查改) 
> jdbc连接数据的过程 
>
> 最后问了几个常规问题: 
> 现在有几个offer了 
> 愿不愿意来北京工作 
> 为什么想来光大/光大有什么吸引你的地方(大概是这个意思具体记不太清了) 
>
> 二面： 
> 二面就非常简单了就随便聊了聊简历(学校，课程，还擅长哪些方面)。然后居然重点问了我的爱好😂一共可能就6.7分钟我觉得一半时间在聊兴趣爱好。 
>
> 总得来说光大面试不是特别难但是很有针对性(岗位和个人)。祝各位兄弟姐妹好运，offer多多

> 刚才[光大科技](https://www.nowcoder.com/jump/super-jump/word?word=光大科技)面 死问多线程 java明明辣么多知识点 线程不擅长呐 枯了
>
> 线程见通信方式 锁 实现方法 一类都挺基础的 别的问的比较少 也不难

>1.自我介绍；2.根据简历提问；我的那次面试都是技术问题。
>
>二面有很多同学，需要排队进行，也是时间问题。只要简历上的东西熟悉，基础扎实就不用慌。

> 其实光大的二面挺简单的，会问基础知识，但是回答时尽量多说点，会问有没有offer

### 上海映驰科技有限公司（失败）

6.11 公司现场笔试+面试

c++字符串处理的基础题，但是根本做不出来。

### 阿里测开（失败）

6.9 电话面试

> 惨不忍睹

ping的过程

java反射

面向对象的三个要素

get方法与post方法

Java spring

如何解决hash冲突

# 测试开发面试准备

很多的问题都是基于项目展开的，简历中没有提到可能不会去问这方面的知识点。

## 一、算法题

### 快速排序

三种基本的排序算法也需要自己实现一下

### 归并排序

应该没有问题，6月5日做题确认过了。由此还延伸出一个题目“数组中的逆序对”

### 链表环路

剑指offer

### 字符串的回文子串

（时间原因，暂时不去实现）

中心扩散法

动态规划

```java
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```



### 第K的数（优化快排）

### [字符串变形](https://www.nowcoder.com/jump/super-jump/word?word=字符串变形)

**思路**：将字符串按“ ”进行分割，得到一系列的小字符串，分别压入栈中，在分别弹出，此时再对字符串的大小写进行修改。

**问题**：题目中只是提出“由空格隔开”，但是没有具体说明空格的数量。同时字符串的头部以及尾部也可能存在空格。因此不能直接用字符串分割函数。

但是一些操作需要记住：

```java
String arr[] = s.split(" ", -1); // 将一个大字符串分割成多个小字符串。
char c = s.charAt(i); // 取字符串的第i个字符
'A' + 32 = 'a'
```

**代码(String)**

优点是进行字符串拼接与字符拼接非常的方便，缺点是每次都会产生一个字符串对象。

```java
import java.util.*;
//不要用split 空格问题会坑死自己
public class Solution {
    public String trans(String s, int n) {
        String res = "";
        String tempStr = "";
        for(int i = 0; i < n; i++){
            char c = s.charAt(i);
            if(c>='a'&& c<='z')
                tempStr += Character.toUpperCase(c);
            else if(c>='A'&& c<='Z')
                tempStr += Character.toLowerCase(c);
            else{
                tempStr = c+tempStr;
                res = tempStr + res;
                tempStr="";
            }
        }
        res = tempStr+res;
        return res;
    }
}
```

改进方式是用StringBuilder，但是问题在于StringBuilder在进行字符添加，字符串拼接，清空等方面很复杂。具体环境下看情况吧。

```java
import java.util.*;

public class Solution {
    public String trans(String s, int n) {
        // write code here
        StringBuilder res = new StringBuilder();
        StringBuilder temp = new StringBuilder();
        for(int i=0;i<n;i++) {
            char c = s.charAt(i);
            if(c >= 'a' && c <= 'z') {
                c -= 32;
                temp.append(c);
            }else if(c >= 'A' && c <= 'Z'){
                c += 32;
                temp.append(c);
            }else {
                // 可能存在多个空格
                temp.insert(0, c);
                res.insert(0, temp.toString());
                temp.delete(0, temp.length());
            }
        }
        res.insert(0, temp.toString());
        return res.toString();
    }
}
```

### 数组存储了一个一半以上的数字，查找这个数字

- 排序取中值
- 两军对拼

### 买卖股票的最好时机

双指针法（贪心算法）

```java
import java.util.*;

public class Solution {
    public int maxProfit (int[] prices) {
        // write code here
        if(prices == null ) {
            return 0;
        }
        int min = prices[0];
        int maxPrice = 0;
        for(int i=1;i<prices.length;i++) {
            min = Math.min(min, prices[i]);
            maxPrice = Math.max(maxPrice, prices[i] - min);
        }
        return maxPrice;
    }
}
```



## 二、智力题

### 2.1 两根可燃1小时的香，要求可计时15分钟（只允许点燃，不允许折断）

A香左右两端同时燃烧，可以用来计时30min。

B香只点燃一端，当A香燃烧结束之后，B香只剩下一半，此时同时点燃B香两端，则15min之后B香燃烧结束。

### 2.2  一根金条，要给一个人七天的工钱，每天给他一段，但是这把刀只能切两次，怎么切

1+2+4=7 7也正好是三维二进制所能够组成的最大数字。

### 2.3 3L和5L水桶各一个,怎样取4L的水?

5-3 = 2

3-2 =1

1+3 =4

### 2.4 一次朋友聚会，大家见面时总共握手45次。如果参加聚会的人和其余的每个人只握手一次，问参加聚会的共有多少人？

就是一个排列组合
$$
C^2_n
$$
n(n-1) /2 = 45，易算出n=10。

## 三、计算机知识题

### 3.1 计算机网络

#### 3.1.1 基础

##### 计算机网络七层模型/五层模型，TCP、IP、HTTP分别位于哪一层

**五层模型**

- **应用层** ：为**特定应用程序**提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。**TCP 主要提供完整性服务，UDP 主要提供及时性服务。**
- **网络层** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成**分组**。
- **数据链路层** ：网络层针对的还是**主机之间**的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的**分组封装成帧**。
- **物理层** ：考虑的是怎样在传输媒体上传输**数据比特流**，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

**七层模型**

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

**TCP/IP协议**

- 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。
- TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

[<img src="https://camo.githubusercontent.com/dfd049aa29f5c514450e4a687bb793b6517025da576dde3aabc1f51edb3dda90/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34386437396265382d303835622d343836322d386139642d3138343032656239336233312e706e67" alt="img" style="zoom:50%;" />](https://camo.githubusercontent.com/dfd049aa29f5c514450e4a687bb793b6517025da576dde3aabc1f51edb3dda90/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34386437396265382d303835622d343836322d386139642d3138343032656239336233312e706e67)

##### TCP与UDP的区别于联系++

|                                        | TCP                                                          | UDP                                                          |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接性                                 |                                                              | 无连接                                                       |
| 可靠性                                 |                                                              | 不可靠；没有确认机制，也没有重传机制。（可以通过应用层实现可靠性） |
| 基本控制                               |                                                              |                                                              |
| 数据单位                               | 报文段                                                       | 用户数据报                                                   |
| 面向                                   | 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） | 面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部） |
| 连接方式                               |                                                              |                                                              |
| 优越性（基于应用场景，选择更优的协议） | 用于可靠传输的情况，例如文件传输，重要状态更新               | 用于高效传输与实时性要求比较高的通信领域。早期的QQ，视频传输，另外还可以用于广播。 |

基于TCP的协议

 1.HTTP 2. HTTPS 3. SSH 4. Telnet 5. FTP 6. SMTP

##### TCP三次握手

需要注意的首部格式：

- 序号：用于对字节流进行编号
- 确认号：期望收到的下一个报文段的序号
- 确认ACK：TCP 规定，在连接建立后所有传送的报文段都必须把ACK 置 1。
- 同步SYN：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- 终止FIN：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

<img src="https://camo.githubusercontent.com/1a8423d689b0c5bd9bcebb68114349f50a0ba5fa4a3584db580b749515b99c50/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67" style="zoom: 67%;" />

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到**连接请求报文**，如果同意建立连接，则向 A 发送**连接确认报文**，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

##### 三次握手原因

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中**滞留**，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会**重新请求连接**。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开**两个连接**。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

> - 第一次握手： A给B打电话说，你可以听到我说话吗？
> - 第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？  
> - 第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！
>
> 在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。 这样，就可以开始正常通信了。
>
> 注意： HTTP是基于TCP协议的，所以每次都是客户端发送请求，服务器应答，但是TCP还可以给其他应用层提供服务，即可能A、B在建立链接之后，谁都可能先开始通信。
>
> 如果两次，那么B无法确定B的信息A是否能收到，所以如果B先说话，可能后面的A都收不到，会出现问题 。
>
> 如果四次，那么就造成了浪费，因为在三次结束之后，就已经可以保证A可以给B发信息，A可以收到B的信息； B可以给A发信息，B可以收到A的信息。

#### （未完成）TCP如何保证可靠传输

#### HTTP

##### HTTP状态码

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

**1XX 信息**

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

**2XX 成功**

- **200 OK**
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

**3XX 重定向**

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

**4XX 客户端错误**

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**
  - 第一种： 用户输入的地址链接有误，导致IIS提示404 not found。
  - 第二种： 服务器上本该有的页面已经被删除了，这种情况多发于BBS论坛，N年前的帖子如今被你通过搜索引擎搜索出来了，但实际上BBS论坛为了保障服务器的资源合理运用，都会将过期或非常久远的信息页面删除，导致404 not found。
  - 第三种： [DNS](https://product.pconline.com.cn/itbk/wlbg/network/1305/3304121.html)设置阻止，就中文环境而言，国外有一些被禁网站在中国浏览同样会出现404 not found的现象，这需要使用代理服务器才可以正常浏览。

**5XX 服务器错误**

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

##### HTTP方法

**GET**

> 获取资源

当前网络请求中，绝大部分使用的是 GET 方法。

[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#head)**HEAD**

> 获取报文首部

和 GET 方法类似，但是不返回报文实体主体部分。

主要用于确认 URL 的有效性以及资源更新的日期时间等。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#post)POST**

> 传输实体主体

POST 主要用来传输数据，而 GET 主要用来获取资源。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#put)PUT**

> 上传文件

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#patch)PATCH**

> 对资源进行部分修改

PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#delete)DELETE**

> 删除文件

与 PUT 功能相反，并且同样不带验证机制。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#options)OPTIONS**

> 查询支持的方法

查询指定的 URL 能够支持的方法。

会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#connect)CONNECT**

> 要求在与代理服务器通信时建立隧道

使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

```html
CONNECT www.example.com:443 HTTP/1.1
```

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg)



**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#trace)TRACE**

> 追踪路径

服务器会将通信路径返回给客户端。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。

通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。

##### HTTP中GET方法与POST方法

**作用**

GET 用于获取资源，而 POST 用于传输实体主体。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#参数)参数**

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。POST 参数支持标准字符集。

```text
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#安全)安全**

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#幂等性)幂等性**

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

所有的安全方法也都是幂等的。

在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：

```text
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
```

POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：

```text
POST /add_row HTTP/1.1   -> Adds a 1nd row
POST /add_row HTTP/1.1   -> Adds a 2nd row
POST /add_row HTTP/1.1   -> Adds a 3rd row
```

DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：

```text
DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -> Returns 404
```

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#可缓存)可缓存**

如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。

**[#](http://www.cyc2018.xyz/计算机基础/HTTP/HTTP.html#xmlhttprequest)XMLHttpRequest**

为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：

> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

- 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
- 而 GET 方法 Header 和 Data 会一起发送。

##### HTTP缺点

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

[<img src="https://camo.githubusercontent.com/d742fcbc48d96d10aeb1996c62410acac607e421adb44cc544105f1f84c3b284/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067" alt="img" style="zoom: 50%;" />](https://camo.githubusercontent.com/d742fcbc48d96d10aeb1996c62410acac607e421adb44cc544105f1f84c3b284/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067)

##### HTTPS认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://camo.githubusercontent.com/f4df5d88f1f914fc81325b00151cefea3994c36827fd18c2a1a5e9f7582e4746/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f323031372d30362d31312d63612e706e67" style="zoom: 67%;" />

> 这个地方说的不好，附上另外一个[链接](https://segmentfault.com/a/1190000004631778)。这个链接中可以理解出大致的内容，但是一些细节值得推敲。

证书由三部分组成：

- tbsCertificate (to be signed certificate)，待签名证书
- SignatureAlgorithm，签名算法
- SignatureValue，签名值

SignatureAlgorithm是指定对tbsCertificate签名使用的算法。SignatureValue是使用SignatureAlgorithm指定的哈希和签名算法对tbsCertificate进行哈希和签名后的签名值。

![](https://segmentfault.com/img/bVtA4r)

我们以某用户访问野狗官网为例，分析身份认证的过程（以下过程并非完整HTTPS握手过程，只是身份认证相关的过程）。

1. 浏览器向Server发送请求；
2. Server返回野狗官网的X.509v3证书，其包含三部分：tbsCertificate、SignatureAlgorithm、SignatureValue；
3. 浏览器读取证书中的tbsCertificate部分（明文），使用SignatureAlgorithm中的散列函数计算得到信息摘要，并利用tbsCertificate中的公钥解密SignatureValue得到信息摘要，然后对比双方的信息摘要，判断是否一致；如果一致，则成功；如果不一致，则失败。

> 左上的消息摘要应该改为签名值。

![图片 8](https://segmentfault.com/img/bVtA4M)

> 用RSA做认证，对极大整数做因素分解。

#### 当在浏览器中输入URL后，页面加载完成的过程中都发生了什么事情++

**[参考链接](https://www.jianshu.com/p/c2bf75485c15)**

1. 解析URL
   1. 判断URL是否是合法的URL，如果URL不合法，则调用默认的搜索引擎，直接把输入的内容作为要搜索的内容进行搜索，如果URL合法，则继续下一步。
   2. 检查这些请求是HTTPS还是HTTP，如果是HTTPS的话则使用HTTPS协议进行访问，否则使用HTTP协议发送。有些情况下，第一个请求不是HTTPS的，但是当浏览器向网站发出第一个HTTP请求之后，网站会返回浏览器一个响应，请求浏览器使用HTTPS发送请求。（如何判断是HTTPS请求还是HTTP请求啊）
   3. 将URL进行字符转换
2. 查找IP地址
   1. 先检查浏览器的缓存，看看所要访问的域名是否存在于缓存之中，如果存在，则直接使用缓存中的IP地址进行访问，如果不存在，执行下一步
   2. 缓存中没有找到，则调用系统的gethostbyname库函数，进行查询，gethostbyname函数会先检查域名是否在本地的Hosts文件中，如果找到直接返回域名对应的IP，（这也当访问不到某网址时，修改hosts文件的原因）如果没有找到则执行下一步
   3. 向DNS服务器发送一个域名查询请求，然后就执行DNS查询过程，这个过程一般情况下会返回所要访问域名对应的IP地址，除非域名真的不存在，或者DNS服务器出现故障。
3. 建立连接
   1. 当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http协议默认端口号是 80， https默认端口号是 443），它会调用系统库函数 socket，请求一个 TCP流套接字。进行网络数据的传输。
   2. 连接建立之后，则根据HTTP协议进行数据交换，资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。
4. 页面渲染
   1. 浏览器获得资源文件后，HTML，css，js等文件则根据自身内核的机制，进行页面渲染，然后呈现给用户。

##### ping的过程发生了什么？？

#### 常见端口号

21/tcp FTP 文件传输协议
22/tcp SSH 安全登录、文件传送(SCP)和端口重定向
23/tcp Telnet 不安全的文本传送
25/tcp SMTP Simple Mail Transfer Protocol (E-mail)

#### 解释DNS

#### 为什么TCP消耗资源比较多？？

#### 

### 3.2 数据库

#### 数据库事务的四个特性

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

[
<img src="https://camo.githubusercontent.com/57b5cb6a1cc1d6b9127ce54bb4f7920170bb86c2d4eb273f36989cee1299fe78/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67" alt="img" style="zoom:50%;" />](https://camo.githubusercontent.com/57b5cb6a1cc1d6b9127ce54bb4f7920170bb86c2d4eb273f36989cee1299fe78/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67)



**ACID**

1. 原子性（Atomicity  [ˌætəˈmɪsəti] ）
   1. **事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。**
   2. 回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. 一致性（Consistency）
   1. **数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。**
3. 隔离性（Isolation  [ˌaɪsəˈleɪʃn] ）
   1. **一个事务所做的修改在最终提交以前，对其它事务是不可见的。**

4. 持久性（Durability [ˌdjʊərəˈbɪlɪti] ）
   1. **一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。**
   2. 系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

------

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

<img src="https://camo.githubusercontent.com/d688683e3f6fb14d059412247e4f427a7cd1aa7686417bc552e061628f24dd84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67" style="zoom: 50%;" />

**AUTOCOMMIT**

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

#### 并发一致性问题

#### mysql索引

**哈希索引**

- 为什么不能用哈希索引，哈希值是个无序的值，没有办法进行范围查找，也没有办法排序。

**平衡二叉树**

- 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1
- 并且左右两个子树都是一棵平衡二叉树
- 解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)
- 频繁旋转会使插入和删除牺牲掉O(logN)左右的时间
- 树越高，查找速度越慢。
- 不方便进行范围查找。（回旋查找）

**B树**

- 一个节点可以存储两个值（？？），相对于平衡二叉树，高度变矮了。
- 不能解决回旋查找的问题。

**B+树**

- 一个节点可以存储两个值（？？），相对于平衡二叉树，高度变矮了。
- 单向链表解决回旋查找的问题，导致了范围查找速度非常高。
- 叶子结点
  - 即存储key，又存储value
- 非叶子节点
  - 只存储key，不存储value

**B+树和B树的区别**

B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。
 **B+ 树的优点在于：**

- **IO次数更少**：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
- **遍历更加方便**：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

#### 为什么MySQL选择B+树做索引

1、 **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3、**B+树更便于遍历**：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

4、**B+树更适合基于范围的查询**：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

#### 内连接（交集）、外连接（左外、右外）、全连接、交叉连接

#### MySQL

##### 数据库优化

<img src="https://pic3.zhimg.com/80/v2-7cfd591cfe1fbf95e29499e335eeb15a_1440w.jpg" style="zoom: 50%;" />

**软优化**

1. 查询语句优化
2. 优化子查询
   1. 在MySQL中,尽量使用JOIN来代替子查询.因为子查询需要嵌套查询,嵌套查询时会建立一张临时表,临时表的建立和删除都会有较大的系统开销,而连接查询不会创建临时表,因此效率比嵌套子查询高.
3. 使用索引
4. 分解表
   1. 对于字段较多的表,如果某些字段使用频率较低,此时应当,将其分离出来从而形成新的表,
5. 中间表
   1. 类似于创建中间表,增加冗余也是为了减少连接查询.
6. 增加冗余字段

### 3.3 LINUX & 操作系统

#### 进程管理

##### 进程与线程的区别

## 进程与线程

**1. 进程**

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

**2. 线程**

线程是独立调度的基本单位。（或者说程序执行的最小单位）

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

**3. 区别**

- 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
- 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（Inter-Process Communication，进程间通信）。

其他的说法：

- 进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。
- 调度和切换：线程上下文切换比进程上下文切换要快得多。

##### chrome是个进程，那么每个标签页是线程吗？为什么？？

https://blog.csdn.net/qq_37969897/article/details/107447733

https://blog.csdn.net/qq_40157234/article/details/82957834

#### **基础命令**

- 文献权限755

  - 第一位7，代表文件所有者拥有的权限为可读（4）+可写（2）+可执行（1）

  - 第二位5，代表文件所有者同组用户的权限为可读（4）+不可写（0）+可执行（1）

  - 第三位5，代表公共用户的权限为可读（4）+不可写（0）+可执行（1）

    > 755表示该文件所有者对该文件具有读、写、执行权限，该文件所有者所在组用户及其他用户对该文件具有读和执行权限。
    >
    > linux文件权限一般都以8进制表示，格式为abc的形式，其中a,b,c各为一个数字，分别表示User、Group、及Other对该文件的操作权限；
    >
    > 如果文件权限用二进制表示那么是9位bit，从左至右，1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限；
    >
    > 而具体的权限是由数字来表示的，读取的权限等于4，用r表示；写入的权限等于2，用w表示；执行的权限等于1，用x表示；
    >
    > 通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）。
    >
    > 并且，linux文件权限不止可以用数字来代表，也可以用10位英文字母来代表：
    >
    > [![img](https://iknow-pic.cdn.bcebos.com/d000baa1cd11728bd44c9ef2c4fcc3cec2fd2cf8?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg)](https://iknow-pic.cdn.bcebos.com/d000baa1cd11728bd44c9ef2c4fcc3cec2fd2cf8)
    >
    > 如图中：
    >
    > 1、首字母代表是否为目录，d为目录，- 为文件
    >
    > 2、第2-4个字母，代表所有者的权限：依次为可读权限 (r)，可写权限(w)，可执行权限(x)，如果某一项权限为不可操作的，则以（-）代表该位。
    >
    > 3、第5-7个字母，代表所有者同组用户权限，权限规则同上。
    >
    > 4、最后三个字母代表公共用户权限。
    >
    > 就比如，一个0755权限的文件写成这种格式话，
    >
    > 0755 等价于 -rwxr-xr-x

- 1.查找文件

  ```text
  find / -name filename.txt
  ```

  根据名称查找/目录下的filename.txt文件。

- 2.查看一个程序是否运行

  ```text
  ps –ef|grep tomcat
  ```

  查看所有有关tomcat的进程

  > ps命令将某个进程显示出来
  >
  > grep命令是查找
  >
  > 中间的|是管道命令 是指ps命令与grep同时执行
  >
  > **-e**: 显示所有进程
  >
  > **-f**: 全格式

- 3.终止线程（或者线程）

  ```text
  kill -9 19979
  ```

  终止线程号位19979的线程，ps命令可以查出。

  -9 代表无条件终止，强制杀死该进程

- 4.查看文件，包含隐藏文件

  ```text
  ls -al
  ```

  ls 显示不隐藏的文件与文件夹

  ls -a //显示当前目录下的所有文件及文件夹包括隐藏的.和..等

  ls -l //显示不隐藏的文件与文件夹的详细信息

  ls -al //显示当前目录下的所有文件及文件夹包括隐藏的.和..等的详细信息

- 5.当前工作目录

  ```text
  pwd
  ```

  目前工作目录的绝对路径名称

- 6.复制文件包括其子文件到自定目录

  ```text
  cp -r sourceFolder targetFolder
  ```

- 7.创建目录

  ```text
  mkdir newfolder
  ```

- 删除目录（此目录是空目录）

  ```text
  rmdir deleteEmptyFolder
  ```

- 删除文件包括其子文件

  ```text
  rm -rf deleteFile
  ```

  -r 递归处理

  -f 强制处理

- 10.移动文件

  ```text
  mv /temp/movefile /targetFolder
  ```

  扩展重命名 mv oldNameFile newNameFile

- 11.切换用户

  ```text
  su -username
  ```

- 12.修改文件权限

  ```text
  chmod 777 file.java
  //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行
  ```

- 13.压缩文件

  ```text
  tar -czf test.tar.gz /test1 /test2
  ```

- 14.列出压缩文件列表

  ```text
  tar -tzf test.tar.gz
  ```

- 15.解压文件

  ```text
  tar -xvzf test.tar.gz
  ```

- 16.查看文件头10行

  ```text
  head -n 10 example.txt
  ```

- 17.查看文件尾10行

  ```text
  tail -n 10 example.txt
  ```

- 18.查看日志文件

  ```text
  tail -f exmaple.log
  //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。
  ```

- 19.启动Vi编辑器

  ```text
  vi
  ```

- 20.查看系统当前时间

  ```text
  date
  ```

  命令会输出 周几 几月 几日 时间 和 时间显示格式 和年份

- 21.解压zip 文件

  ```text
  unzip -oq
  ```

- 22.查看线程个数（方便查看程序是否有误）

  ```text
  ps -Lf 端口号|wc -l
  ```
  
- 23.查看IP地址

  ```text
  ifconfig -a
  ```

- 24.查看路由表

  ```text
  netstat -rn
  route
  ip route  // 打印路由表信息的最佳方法
  ```

  

#### find与grep的区别

实际上, find基本上 就相当于 linux下的 "搜索" , 相当于windows下的搜索功能! 它是用来搜索文件的

而grep则是用来搜索文本的, 用来在standard input或文件内部的内容中, 来搜索 文字 内容 的!

或者说, 因为这两个都是 "搜索" "查找"的相关命令, 所以还是容易混淆的, 但是记住:ｇｒｅｐ是用来查找文字内容的, 而find是用来查找文件的. 这样就清晰了!

find命令从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对之采取相关的操作。

#### **进阶命令**

### 3.4 Java

#### OOP的三个特点

如何实现多态

私有的方法或者属性可以继承/重写吗？

#### 抽象类与接口的区别

**抽象类**

- 抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。
- 抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。

**接口**

- 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。
- 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。
- 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。
- 接口的字段默认都是 static 和 final 的。

**两者比较**

- 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

**使用接口**

- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；
- 需要使用多重继承。

**使用抽象类**

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。



#### **String，StringBuffer，StringBuilder**

- String是个不可继承类（final修饰），也是个不可变类（内部char数组被final修饰）。 

- StringBuffer和StringBuilder内部都是一般的动态数组，所以可变。前者是线程安全的，因为方法基本都被synchronized修饰了。

> 所以算法中一般用Stringbuilder。
>
> 添加字符或者字符串到尾部：`sb.append(c) sb.append(str)`
>
> 添加字符或者字符串到头部：`sb.insert(0, c) sb.insert(0, str)`
>
> 清空Stringbuilder：` sb.delete(0, sb.length());` `sb3.setLength(0);`
>
> 将第 i 个代码单元设置为 c（可以理解为替换）：`setCharAt(int i, char c)`

#### final

**1. 数据**

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

**2. 方法**

声明方法不能被子类重写。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

**3. 类**

声明类不允许被继承。

#### static关键字

#### Java里面的内存模型

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" alt="img" style="zoom:50%;" />

### 程序计数器

记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。

#### Java的垃圾回收

#### overload与override的区别

Sprint IOC 

 String怎么创建一个字符串对象 

 String可以继承么？（没注意这一点，当时不太确定） 

 接着就问了了不了解final关键字（问完这，九成是不可继承了） 

 GC[算法]() 

 多线程 

 线程池

### 3.5 设计模式

项目中用到的设计模式。

#### 单例模式

单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式；

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。

#### 简单工厂模式

- 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

- 简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。

#### MVC模式（架构 or 设计模式？）

**什么是MVC (模型 视图 控制器)?**

MVC是一个架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器。下面是每一个部件的分工：

- 视图是用户看到并与之交互的界面。
- 模型表示业务数据，并提供数据给视图。
- 控制器接受用户的输入并调用模型和视图去完成用户的需求。

![img](http://img0.tuicool.com/zAnI3q.jpg!web)

图: MVC (模型、视图、控制器)

**你能解释下MVC的完整流程吗？**

下面是MVC（模型、视图、控制器）架构的控制流程：

- 所有的终端用户请求被发送到控制器。
- 控制器依赖请求去选择加载哪个模型，并把模型附加到对应的视图。
- 附加了模型数据的最终视图做为响应发送给终端用户。

## MVC同时适用于Windows应用和Web应用吗?

相比Windows应用，MVC架构更适用于Web应用。对于Windows应用，MVP(Model View Presenter )架构更好一点。如果你使用WPF和Silverlight，MVVM更适合。

## 使用MVC有哪些好处?

MVC有两个大的好处：

- 分离了关注点。后台代码被移到单独的类文件，我们可以最大限度的重复利用代码。
- 自动化UI测试成为可能，因为后台代码移到了.NET类。这让我们更容易做单元测试和自动化测试。

## MVC不同于三层架构？

MVC是三层传统架构的演变。三层架构和MVC有一些通用的组成部分。 显示如下：

| 功能性             | 三层 / 分层架构 | Model view controller architecture |
| ------------------ | --------------- | ---------------------------------- |
| 显示与交互         | 用户界面        | 视图                               |
| UI逻辑             | 用户界面        | 控制器                             |
| 商业逻辑 / 验证    | 中间层          | 模型                               |
| 请求首先发送给谁？ | 用户界面        | 控制器                             |
| 访问数据           | 数据链接层      | 数据链接层                         |

![img](http://img1.tuicool.com/n6nQfq.jpg!web)

图示: 三层架构

### 3.6 SQL

sql语句 查出重复的语句

### 3.7 Redis

对于Redis的理解

> 根本就看不懂

#### [缓存穿透、缓存击穿、缓存雪崩区别和解决方案](https://blog.csdn.net/kongtiao5/article/details/82771694)

**一、缓存处理流程**

   前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。

   ![img](https://img-blog.csdn.net/20180919143214712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmd0aWFvNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

二、缓存穿透

描述：

- 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

  

解决方案：

- 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。

三、缓存击穿

描述

- 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

解决方案：

- 设置热点数据永远不过期。
-   加互斥锁，互斥锁参考代码如下：

四、缓存雪崩

描述

- 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

解决方案：

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
- 设置热点数据永远不过期。


### 3.8 Python

#### Python的内存管理机制

#### Django

Django的MTV模式

Model(模型)：负责业务对象与数据库的对象(ORM)

​    Template(模版)：负责如何把页面展示给用户

​    View(视图)：负责业务逻辑，并在适当的时候调用Model和Template

## 四、测试题

### 软件开发流程



### 测试是什么？

通过测试用例来分析软件中的不足或者缺陷

把发现的问题整理形成报告

分析软件质量的好坏。

### 为什么选择测试，对测试开发的理解，相比较其他人自己的优势在哪里（？？？）

### 测试用例——一个杯子的测试用例设计（考虑咖啡杯需要额外考虑的问题）

要从软件的质量特性来思考这个问题：

功能性、可靠性、易用性、效率、可维护性、可移植性

> 可维护性：软件在环境改变或发生错误时，进行修改的难易程度。
> 可移植性：软件能够方便地移植到不同运行环境的程度。

仔细来说：

- 功能性：
  - 杯子的容量：能装多少升水，少量、半杯、满杯。
  - 杯子的形状eg：圆形、上口大、下口小。
  - 杯子的材料：纸杯。
  - 杯子的耐温度：装冷水、冰水、热水。
  - 用杯子装水，看是否能喝到
  - 杯子是否可以盛放不同的饮料（咖啡、酒精、牛奶、碳酸饮料）
- 可靠性
  - 盛冷水和热水时分别盛多少水杯能够承受。
  - （对于咖啡杯）
  - 杯子是否会漏水
  - 被子从不同的高度落下的损坏程度
- 易用性：
  - 杯子是否方便饮用。
  - 装热水时杯子是否烫手。（温度对杯子的影响，烫手、冻手）
  - 杯子是否有防滑措施。
- 安全性
  - 是否容易滋生细菌
  - 热水或者凉水是否会与杯壁材料发生反应，产生有害物质，或者异味。
  - 不同的液体会不会发生反应（咖啡、酒精、牛奶、碳酸饮料）
- 效率
- 可移植性
  - 杯子在不同的环境、温度下是否都能够正常的使用。
- 破坏测试
  - 水杯的最大的拉扯以及挤压的承受能力
  - 水杯破坏之后，能否对使用者造成伤害
  - 极端情况下，用水杯投掷别人，会不会对其他人造成伤害。

### 场景题：微信点赞功能测试用例

**功能测试**

1.给某个好友点赞，点赞数+1，点赞栏显示具体点赞人的名字 ，该用户手动点赞回馈
 2.点完赞后，共同好友在点赞区能看到该人是不是点赞
 了，非共同好友看不到
 3.两个头像一样的人点赞，能否正确显示
 4.点完赞后，在点击点变成点赞取消
 5.取消点赞--不通知用户
 6.点赞后，通知用户，取消，在点赞，此时不通知用户
 7.多个用户同时对其点赞，点赞数正常
 8.最多能点多少个赞--边界值测试
 9.可以从点击点赞区头像，进入相应人的主页查看
 10.点赞是否按照时间顺序排序
 11.点赞后是否能够正常评论

**app端测试**

1.弱网情况下，点赞能否实时更新
 2.点赞时，有短信或者电话进来，能否显示点赞情况
 3.耗电量，耗流量关注

**性能测试**

1大量用户并发点赞时，该接口的响应时间，最大承受的qps
 2.大量用户并发点赞时，此时界面进行点赞，点赞功能是否正常

**兼容性测试**

1.不同手机型号，点赞功能，显示功能是否正常



作者：woshi开心
链接：https://www.jianshu.com/p/0fbf91b459b7
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 场景题：怎么测用户手机号+验证码登录这个界面（嗐，说多了都是泪）

### 场景题：朋友圈刷新很慢，怎么测这个问题

### 微信评论的用例

### [面筋-测开-软件测试概述/对测试的理解](https://www.cnblogs.com/anliux/p/12727282.html)

## 五、特殊

### 项目中的技术难题是如何解决的？



